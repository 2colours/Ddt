#!/usr/bin/env perl6
use v6;
use Ddt::Distribution;
use META6;
use Zef;
use Zef::Config;
use Zef::Client;
use Zef::Identity;
use License::Software;

sub author { qx{git config --global user.name}.chomp }
sub email { qx{git config --global user.email}.chomp }
sub TOPDIR of IO::Path:D { 
    my Proc:D $proc = Proc.new(:out, :err);
    $proc.shell: 'git rev-parse --show-toplevel';
    my $dir = $proc.out.slurp-rest;
    unless $dir {
        return fail "Not in a repository"
    } 
    return $dir.chomp.IO
}

#| Create new module
multi MAIN("new",
            $module is copy, #= Module::To::Create
            :$license-name = 'GPLv3' #= License name
        ) {
    my $distri-name = $module.subst: '::', '-', :g;
    my $main-dir = $distri-name.IO;
    die "Already exists $main-dir" if $main-dir.IO ~~ :d;

    mkdir($main-dir);
    my $license-holder = author() ~ " " ~ email();
    my $url = License::Software::get($license-name).new($license-holder).url;
    my $meta = META6.new:   name => $distri-name,
                            authors => [author()],
                            license => $url,
                            version => Version.new('*'),
                            perl-version => $*PERL.version;

    my $meta-file = $main-dir.IO.child(<META6.json>);
    $meta-file.spurt: $meta.to-json(:skip-null);
    my $ddt = Ddt::Distribution.new: $meta-file;
    $ddt.generate-all: :force;
    note "Successfully created $main-dir";
}

#| Build the module in current directory
multi MAIN("build") {
    my $ddt = Ddt::Distribution.new: TOPDIR;
    $ddt.generate-README;
    $ddt.generate-META6;
    return unless "Build.pm".IO.e;
    run "zef", "build", ".";
}

multi MAIN("test") {
    run "zef", "test", "."
}

#| Make release
multi MAIN("release") {
    my $ddt = Ddt::Distribution.new: TOPDIR;
    my ($user, $repo) = guess-user-and-repo($ddt.META6<source-url>);
    my Str:D $meta-file = $ddt.meta-file.basename;
    my Str:D $module = $ddt.name;
    die "Cannot find user and repository settting" unless $repo;
    say  qq:to/EOF/;
    Are you ready to release your module? Congrats!
    For this, follow these steps:

    1. Fork https://github.com/perl6/ecosystem repository.
    2. Add https://raw.githubusercontent.com/$user/$repo/master/$meta-file to META.list.
    3. And raise a pull request!


    Once your pull request is merged, we can install your module by:

    \$ zef install $module
    EOF
}

sub cand-name($candi) of Str:D {
    my Str:D $name = $candi.dist.source-url.IO.basename;
    if $name.IO.extension eq 'git' {
        $name = $name.comb[0..*-5].join;
    }
    return $name;
}

#| Checkout a Distribution and start hacking on it
multi MAIN("hack", Str:D $identity, Str $dir?) {

    if !$dir.defined && TOPDIR().defined {
        die "You are already in a repository please specify exact dir to clone to"
    }

    my Zef::Client:D $client     = get-client;
    my @candidates = $client.search( str2identity($identity) );
    die "No candidates found" unless @candidates.elems;
    my Str:D $target = ($dir || cand-name @candidates.first);
    die "Directory $target already exists" if $target.IO.e;

    my Str:D $uri = @candidates.first.dist.source-url;

    my (:@remote, :@local) := @candidates.classify: {.dist !~~ Zef::Distribution::Local ?? <remote> !! <local>}
    unless @local.first {
        @local.push: $client.fetch(@remote[0])
    }

    my $candi = @local.first;
    my IO::Path:D $local-mirror = $client.config<TempDir>.IO.child($uri.IO.basename);
    say qqx{git clone $uri --reference $local-mirror.Str() $target};
    say "Checked out $uri to $target";
    say "You can now do `cd $target`";
}


sub guess-user-and-repo(Str:D $url) {
    return if $url eq "";
    if $url ~~ m{ (git|https?) '://'
        [<-[/]>+] '/'
        $<user>=[<-[/]>+] '/'
        $<repo>=[.+?] [\.git]?
    $} {
        return $/<user>, $/<repo>;
    } else {
        return;
    }
}

sub get-client {
    my $config = do {
        # The .Str.IO thing is due to a weird rakudo bug I can't figure out .
        # A bare .IO will complain that its being called on a type Any (not true)
        my $path = Zef::Config::guess-path;
        my $IO   = $path.Str.IO;
        my %hash = Zef::Config::parse-file($path).hash;
        class :: {
            has $.IO;
            has %.hash handles <AT-KEY EXISTS-KEY DELETE-KEY push append iterator list kv keys values>;
        }.new(:%hash, :$IO);
    }
    my $verbosity = DEBUG;
    my $client = Zef::Client.new(:$config);
    my $logger = $client.logger;
    my $log    = $logger.Supply.grep({ .<level> <= $verbosity });
    $log.tap: -> $m {
        given $m.<phase> {
            when BEFORE { say "===> {$m.<message>}" }
            when AFTER  { say "===> {$m.<message>}" }
            default     { say $m.<message> }
        }
    }
    $client;
}
